<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Manifest管理 on ニコニコ生放送 Webフロントエンド Kubernetes移行ハンドブック 2022</title><link>https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/</link><description>Recent content in Manifest管理 on ニコニコ生放送 Webフロントエンド Kubernetes移行ハンドブック 2022</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><atom:link href="https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/index.xml" rel="self" type="application/rss+xml"/><item><title>KubernetesのManifest管理</title><link>https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/manifest-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/manifest-management/</guid><description>KubernetesのManifest管理 # ここではManifestの管理をどのように実施しているかについて紹介します。 結果から言えば、Kubernetesで利用するManifestを生成するGeneratorをTypeScriptで構築しました。
どのように構築して運用しているのか説明していきます。
移行後の各Componentのファイル数の規模感 # 導入でも提示していますが改めて、フロントエンドに関係するマイクロサービスのManifestは以下の規模で存在しています。 これは簡単に管理するとは言えないコンポーネント数があり、これからも増えていきます。
Component ファイル数 v1/Deployment 20 v1/Service 60 v1/Config Map 15 batch/v1/Job 15 argoproj.io/v1alpha1/Rollout 20 networking.istio.io/v1beta1/VirtualService 20 networking.istio.io/v1alpha3/EnvoyFilter 20 問題意識 # 移行前の段階ですでにファイル数はYAMLで保守するには困難な量が発生することはわかっており、ツールによる補完支援やテスト無しでは必ず破綻することが容易に想定されました。また、これらは最初に定めた2つの目標に反します。
デプロイが素早く簡単にそして安全に実施できる Webフロントエンド開発者が更新に必要な最低限の設定の変更を簡単に実施できる TypeScriptでManifestの保守面の問題を解決する # これらを網羅的に解決する一つの方法としてTypeScriptによりKubernetesのYAMLを生成することです。 TypeScript自体の利点は各種記事に譲るとして、Kubernetesを運用するチームの背景としてTypeScriptを日常的に利用しているWebフロントエンドのエンジニアたちです。
したがって、TypeScriptでManifestを記述すること自体は非常に障壁がほとんど皆無という状態です。 またManifest自体のテストもTypeScriptからYAMLを生成するタイミングでExceptionを投げてしまえば良いだけなので、テストの方針も非常に単純になります。
仮にTypeScriptで書くのを辞めたいといった場合は生成されたYAMLを持っていけば良いので、TypeSCript自体を切り捨てることも簡単になります。
以上の理由からTypeScriptで記述しない理由が移行の設計段階で存在しないため、ManifestをYAMLで書くことを初手で捨て、TypeScriptで記述するようにしました。
TypeScriptでKubernetesを書くための支援ライブラリとSchema # KubernetesはCustomResourceDefinitionを定義する際OpenAPI Schema V3で記述できます。 これによってSchemaがApply時にValidationされています。 逆に言えば、OpenAPI SchemaをTypeScriptの型定義に書き起こしてしまえばValidationをTypeScriptの静的型付けに変換することができます。</description></item><item><title>TypeScriptでKubernetesのmanifestを記述する</title><link>https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-written-by-typescript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-written-by-typescript/</guid><description>TypeScriptでKubernetesのmanifestを記述する # ここでは基本的な書き方について紹介します。
基本的な書き方 # NodeJSで動かすスクリプトとして次のようなに記述してきます。 これをts-nodeなどで実行するとdeployment.ymlが出力され、kubectl apply -f deployment.ymlとすることでKubernetes上にPodが起動します。
import * as fs from &amp;#34;fs&amp;#34;; import * as yaml from &amp;#34;js-yaml&amp;#34;; import type { Schemas } from &amp;#34;@himenon/kubernetes-typescript-openapi/v1.22.3&amp;#34;; const podTemplateSpec: Schemas.io$k8s$api$core$v1$PodTemplateSpec = { metadata: { labels: { app: &amp;#34;nginx&amp;#34;, }, }, spec: { containers: [ { name: &amp;#34;nginx&amp;#34;, image: &amp;#34;nginx:1.14.2&amp;#34;, ports: [ { containerPort: 80, }, ], }, ], }, }; const deployment: Schemas.</description></item><item><title>TypeScriptでManifestを生成するGeneratorのアーキテクチャ</title><link>https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-generator-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-generator-architecture/</guid><description>TypeScriptでManifestを生成するGeneratorのアーキテクチャ # アーキテクチャが解決すること # そもそも Generator そのものが解決することは manifest をドキュメントの乖離を防ぎ、YAMLの記法のぶれなどを防ぐことです。 アーキテクチャが解決しなければいけないことは、具体的には次のようなことが挙げられます。
マニフェスト自体のスケーラビリティを確保する 実際に運用する際に必要最小限の変更だけで Manifest を更新できる ≒ 宣言的な変更で済むようにする マイクロサービス単位で設定の変更ができる（CPU/MEM/replicas など） 管理しているマイクロサービス全体のリソース量、変更時の増減が把握できる Manifest ファイルの命名規則、出力先のディレクトリ・ファイルツリーなどを意識しなくても良い Generator 自体の保守性を高める これらを表現するためのアーキテクチャはStatic Site GeneratorやYeoman、Cookiecutter、Rails Scaffoldなどたくさん事例があります。 これらの基本的な骨格をKubernetesのManifest Generatorとして応用し次のようなアーキテクチャが設計しました。
それぞれの役割を紹介します。
名称 役割 User Config バージョン変更など最小限の変更を与えるファイル Kubernetes TypeDefinition TypeScriptの型定義 MicroService Template マイクロサービスの種類に応じたテンプレート Definition Namespace名やPort番号、Gatewayの Host 名などの不動値の定義 Resource ParameterとMicroService Templateを Kubernetes のリソースコンポーネント単位で結合する Factory Resourceをどのファイル名でどのグループで出力するか定義する Writer Factory から与えられた情報から Kubernetes の Manifest や、CPU Requests などのレポートを生成する 具体的な実装例 # 実装サンプルを以下のリポジトリに用意しました。nodejsとpnpmを利用したサンプルとなっています。 Docker Swarmを利用すればArgo Rollouts + Istioがデプロイできるところまで確認しています。</description></item></channel></rss>