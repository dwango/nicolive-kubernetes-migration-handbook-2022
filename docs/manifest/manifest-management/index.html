<!doctype html><html lang=ja-jp dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Kubernetes の Manifest 管理 #  ここではManifestの管理をどのように実施しているかについて紹介します。 結果から言えば、Kubernetesで利用するManifestを生成するGeneratorをTypeScriptで構築しました。
どのように構築して運用しているのか説明していきます。
移行後の各Componentのファイル数の規模感 #  導入でも提示していますが改めて、フロントエンドに関係するマイクロサービスに関係するManifestは以下の規模で存在しています。 これは簡単に管理するとは言えないコンポーネント数があり、これからも増えていきまうｓ．
   Component ファイル数     v1/Deployment 20   v1/Service 60   v1/Config Map 15   batch/v1/Job 15   argoproj.io/v1alpha1/Rollout 20   networking.istio.io/v1beta1/VirtualService 20   networking.istio.io/v1alpha3/EnvoyFilter 20    問題意識 #  移行前の段階ですでにファイル数はYAMLで保守するには困難な量が発生することはわかっており、ツールによる補完支援やテスト無しでは必ず破綻することが容易に想定されました。また、これらは最初に定めた2つの目標に反します。
 デプロイが素早く簡単にそして安全に実施できる Webnフロントエンド開発者が更新に必要な最低限の設定の変更を簡単に実施できる  TypeScriptでManifestの保守面の問題を解決する #  これらを網羅的に解決する一つの方法としてTypeScriptによりKubernetesのYAMLを生成することです。 TypeScript自体の利点は各種記事に譲るとして、Kubernetesを運用するチームの背景としてTypeScriptを日常的に利用しているWebフロントエンドのエンジニアたちです。
したがって、TypeScriptでManifestを記述すること自体は非常に障壁がほとんど皆無という状態です。 またManifest自体のテストもTypeScriptからYAMLを生成するタイミングでExceptionを投げてしまえば良いだけなので、テストの方針も非常に単純になります。
仮にTypeScriptで書くのを辞めたいといった場合は生成されたYAMLを持っていけば良いので、TypeSCript自体を切り捨てることも簡単になります。
以上の理由からTypeScriptで記述しない理由が移行の設計段階で存在しないため、ManifestをYAMLで書くことを初手で捨て、TypeScriptで記述するようにしました。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="KubernetesのManifest管理"><meta property="og:description" content="Kubernetes の Manifest 管理 #  ここではManifestの管理をどのように実施しているかについて紹介します。 結果から言えば、Kubernetesで利用するManifestを生成するGeneratorをTypeScriptで構築しました。
どのように構築して運用しているのか説明していきます。
移行後の各Componentのファイル数の規模感 #  導入でも提示していますが改めて、フロントエンドに関係するマイクロサービスに関係するManifestは以下の規模で存在しています。 これは簡単に管理するとは言えないコンポーネント数があり、これからも増えていきまうｓ．
   Component ファイル数     v1/Deployment 20   v1/Service 60   v1/Config Map 15   batch/v1/Job 15   argoproj.io/v1alpha1/Rollout 20   networking.istio.io/v1beta1/VirtualService 20   networking.istio.io/v1alpha3/EnvoyFilter 20    問題意識 #  移行前の段階ですでにファイル数はYAMLで保守するには困難な量が発生することはわかっており、ツールによる補完支援やテスト無しでは必ず破綻することが容易に想定されました。また、これらは最初に定めた2つの目標に反します。
 デプロイが素早く簡単にそして安全に実施できる Webnフロントエンド開発者が更新に必要な最低限の設定の変更を簡単に実施できる  TypeScriptでManifestの保守面の問題を解決する #  これらを網羅的に解決する一つの方法としてTypeScriptによりKubernetesのYAMLを生成することです。 TypeScript自体の利点は各種記事に譲るとして、Kubernetesを運用するチームの背景としてTypeScriptを日常的に利用しているWebフロントエンドのエンジニアたちです。
したがって、TypeScriptでManifestを記述すること自体は非常に障壁がほとんど皆無という状態です。 またManifest自体のテストもTypeScriptからYAMLを生成するタイミングでExceptionを投げてしまえば良いだけなので、テストの方針も非常に単純になります。
仮にTypeScriptで書くのを辞めたいといった場合は生成されたYAMLを持っていけば良いので、TypeSCript自体を切り捨てることも簡単になります。
以上の理由からTypeScriptで記述しない理由が移行の設計段階で存在しないため、ManifestをYAMLで書くことを初手で捨て、TypeScriptで記述するようにしました。"><meta property="og:type" content="article"><meta property="og:url" content="https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/manifest-management/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-06-02T17:14:12+09:00"><title>KubernetesのManifest管理 | ニコニコ生放送 Webフロントエンド Kubernetes移行ハンドブック 2022</title><link rel=manifest href=/nicolive-kubernetes-migration-handbook-2022/manifest.json><link rel=icon href=/nicolive-kubernetes-migration-handbook-2022/favicon.png type=image/x-icon><link rel=stylesheet href=/nicolive-kubernetes-migration-handbook-2022/book.min.fcc3ce6727c2b2b91bc9a518374b77e2097222f7fe4dc0016db675da315da284.css integrity="sha256-/MPOZyfCsrkbyaUYN0t34glyIvf+TcABbbZ12jFdooQ=" crossorigin=anonymous><script defer src=/nicolive-kubernetes-migration-handbook-2022/flexsearch.min.js></script>
<script defer src=/nicolive-kubernetes-migration-handbook-2022/en.search.min.316dfec6e198e1d4e40887d7250e8b92d7bde449cce89841b69417adbdc06208.js integrity="sha256-MW3+xuGY4dTkCIfXJQ6Lkte95EnM6JhBtpQXrb3AYgg=" crossorigin=anonymous></script>
<script defer src=/nicolive-kubernetes-migration-handbook-2022/sw.min.dd2d6bf3c93d9223651db8ea5867f95fed658724b711f7b9e9e1d8aa46a84ebd.js integrity="sha256-3S1r88k9kiNlHbjqWGf5X+1lhyS3Efe56eHYqkaoTr0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/nicolive-kubernetes-migration-handbook-2022/><span>ニコニコ生放送 Webフロントエンド Kubernetes移行ハンドブック 2022</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>ネットワーク</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/network/architecture/>移行前・移行中・移行後のネットワーク設計</a></li></ul></li><li><span>Manifest管理</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/manifest/manifest-management/ class=active>KubernetesのManifest管理</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-written-by-typescript/>TypeScriptでKubernetesのmanifestを記述する</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-generator-architecture/>TypeScriptでManifestを生成するGeneratorのアーキテクチャ</a></li></ul></li><li><span>Continuous Delivery</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/ci/argo-cd/>Argo CDの利用</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/ci/argo-rollouts/>Argo Rolloutsの利用</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/ci/slack-bot/>Slack Botによる自動化</a></li></ul></li><li><span>Service Mesh (Istio)</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/service-mesh/istio/>BFFとIstio</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/service-mesh/access-log/>アクセスログ</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/service-mesh/traffic-management/>Istio Ingress Gatewayの設定</a></li></ul></li><li><span>Rate Limit</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/rate-limit/global-ratelimit/>Global RateLimit</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/rate-limit/local-ratelimit/>Local RateLimit</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/rate-limit/ratelimit-is-unless/>RateLimitで負荷の上昇を防げないパターン</a></li></ul></li><li><span>スケーリング</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/scalability/horizontal-pod-autoscaler/>水平スケール</a></li></ul></li><li><span>負荷</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/performance/load-test/>負荷試験</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/performance/monitoring/>モニタリング</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/performance/load-balancing/>負荷分散</a></li></ul></li><li><span>Docker SwarmからKubernetesへの移行</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/migrate-practice/migrate-docker-swarm-to-kubernetes/>移行の実施</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/migrate-practice/application/>アプリケーションの移行</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/nicolive-kubernetes-migration-handbook-2022/svg/menu.svg class=book-icon alt=Menu></label>
<strong>KubernetesのManifest管理</strong>
<label for=toc-control><img src=/nicolive-kubernetes-migration-handbook-2022/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#移行後の各componentのファイル数の規模感>移行後の各Componentのファイル数の規模感</a></li><li><a href=#問題意識>問題意識</a><ul><li><a href=#typescriptでmanifestの保守面の問題を解決する>TypeScriptでManifestの保守面の問題を解決する</a></li></ul></li><li><a href=#typescriptでkubernetesを書くための支援ライブラリとschema>TypeScriptでKubernetesを書くための支援ライブラリとSchema</a></li><li><a href=#他のライブラリ>他のライブラリ</a></li></ul></nav></aside></header><article class=markdown><h1 id=kubernetes-の-manifest-管理>Kubernetes の Manifest 管理
<a class=anchor href=#kubernetes-%e3%81%ae-manifest-%e7%ae%a1%e7%90%86>#</a></h1><p>ここではManifestの管理をどのように実施しているかについて紹介します。
結果から言えば、Kubernetesで利用するManifestを生成するGeneratorをTypeScriptで構築しました。</p><p>どのように構築して運用しているのか説明していきます。</p><h2 id=移行後の各componentのファイル数の規模感>移行後の各Componentのファイル数の規模感
<a class=anchor href=#%e7%a7%bb%e8%a1%8c%e5%be%8c%e3%81%ae%e5%90%84component%e3%81%ae%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e6%95%b0%e3%81%ae%e8%a6%8f%e6%a8%a1%e6%84%9f>#</a></h2><p><a href=/docs/01/introduction/#kubernetes%e3%81%a7%e3%81%ae%e7%a8%bc%e5%83%8d%e8%a6%8f%e6%a8%a1>導入</a>でも提示していますが改めて、<strong>フロントエンドに関係するマイクロサービス</strong>に関係するManifestは以下の規模で存在しています。
これは簡単に管理するとは言えないコンポーネント数があり、これからも増えていきまうｓ．</p><table><thead><tr><th style=text-align:left>Component</th><th style=text-align:right>ファイル数</th></tr></thead><tbody><tr><td style=text-align:left>v1/Deployment</td><td style=text-align:right>20</td></tr><tr><td style=text-align:left>v1/Service</td><td style=text-align:right>60</td></tr><tr><td style=text-align:left>v1/Config Map</td><td style=text-align:right>15</td></tr><tr><td style=text-align:left>batch/v1/Job</td><td style=text-align:right>15</td></tr><tr><td style=text-align:left>argoproj.io/v1alpha1/Rollout</td><td style=text-align:right>20</td></tr><tr><td style=text-align:left>networking.istio.io/v1beta1/VirtualService</td><td style=text-align:right>20</td></tr><tr><td style=text-align:left>networking.istio.io/v1alpha3/EnvoyFilter</td><td style=text-align:right>20</td></tr></tbody></table><h2 id=問題意識>問題意識
<a class=anchor href=#%e5%95%8f%e9%a1%8c%e6%84%8f%e8%ad%98>#</a></h2><p>移行前の段階ですでにファイル数はYAMLで保守するには困難な量が発生することはわかっており、ツールによる補完支援やテスト無しでは必ず破綻することが容易に想定されました。また、これらは最初に定めた2つの目標に反します。</p><ul><li>デプロイが素早く簡単にそして安全に実施できる</li><li>Webnフロントエンド開発者が更新に必要な最低限の設定の変更を簡単に実施できる</li></ul><h3 id=typescriptでmanifestの保守面の問題を解決する>TypeScriptでManifestの保守面の問題を解決する
<a class=anchor href=#typescript%e3%81%a7manifest%e3%81%ae%e4%bf%9d%e5%ae%88%e9%9d%a2%e3%81%ae%e5%95%8f%e9%a1%8c%e3%82%92%e8%a7%a3%e6%b1%ba%e3%81%99%e3%82%8b>#</a></h3><p>これらを網羅的に解決する一つの方法としてTypeScriptによりKubernetesのYAMLを生成することです。
TypeScript自体の利点は各種記事に譲るとして、Kubernetesを運用するチームの背景としてTypeScriptを日常的に利用しているWebフロントエンドのエンジニアたちです。</p><p>したがって、TypeScriptでManifestを記述すること自体は非常に障壁がほとんど皆無という状態です。
またManifest自体のテストもTypeScriptからYAMLを生成するタイミングで<code>Exception</code>を投げてしまえば良いだけなので、テストの方針も非常に単純になります。</p><p>仮にTypeScriptで書くのを辞めたいといった場合は生成されたYAMLを持っていけば良いので、TypeSCript自体を切り捨てることも簡単になります。</p><p>以上の理由からTypeScriptで記述しない理由が移行の設計段階で存在しないため、ManifestをYAMLで書くことを初手で捨て、TypeScriptで記述するようにしました。</p><h2 id=typescriptでkubernetesを書くための支援ライブラリとschema>TypeScriptでKubernetesを書くための支援ライブラリとSchema
<a class=anchor href=#typescript%e3%81%a7kubernetes%e3%82%92%e6%9b%b8%e3%81%8f%e3%81%9f%e3%82%81%e3%81%ae%e6%94%af%e6%8f%b4%e3%83%a9%e3%82%a4%e3%83%96%e3%83%a9%e3%83%aa%e3%81%a8schema>#</a></h2><p>Kubernetesは<code>CustomResourceDefinition</code>を定義する際OpenAPI Schema V3で記述できます。
これによってSchemaがApply時にValidationされています。
逆に言えば、OpenAPI SchemaをTypeScriptの型定義に書き起こしてしまえばValidationをTypeScriptの静的型付けに変換することができます。</p><p>幸いにして筆者はOpenAPI SchemaとTypeScriptの話にはちょっとだけ詳しいので、
手前味噌ですが<a href=https://github.com/Himenon/openapi-typescript-code-generator>@himenon/openapi-typescript-code-generator</a>を利用してKubernetesの型定義を生成しました。</p><ul><li><a href=https://github.com/Himenon/kubernetes-typescript-openapi>@himenon/kubernetes-typescript-openapi</a></li><li><a href=https://github.com/Himenon/argocd-typescript-openapi>@himenon/argocd-typescript-openapi</a></li><li><a href=https://github.com/Himenon/argo-rollouts-typescript-openapi>@himenon/argo-rollouts-typescript-openapi</a></li></ul><p>もちろん他にも同じようなアプローチで型定義を提供しているものもありますが、以下の点で見送りをしています。</p><ul><li>TypeScriptのObjectに対してシンプルに型定義を当てたい<ul><li>これはライブラリ側のメンテナンスが滞っても自分たちで書き直すことができるため</li></ul></li><li>ArgoCDやArgoRollouts、Istioなど他のCustom Resource利用時も同じライブラリの使い勝手になるようにしたい</li><li>最新だけでなく任意の古いバージョンもサポートするようにする</li></ul><p>これらを考えたときになるべくライブラリは薄く実装されているのが望ましく、型定義ライブラリをForkしたときも簡単にメンテナンスできる実装ベースが必要でした。これらの条件を満たす設計コンセプトで豊富な知見があるライブラリは<a href=https://github.com/Himenon/openapi-typescript-code-generator>@himenon/openapi-typescript-code-generator</a>でした。</p><p>次の節でより詳細に紹介します。</p><ul><li><a href=../kubernetes-manifest-written-by-typescript/>TypeScriptでKubernetesのmanifestを記述する</a></li><li><a href=../kubernetes-manifest-generator-architecture/>TypeScriptでManifestを生成するGeneratorのアーキテクチャ</a></li></ul><h2 id=他のライブラリ>他のライブラリ
<a class=anchor href=#%e4%bb%96%e3%81%ae%e3%83%a9%e3%82%a4%e3%83%96%e3%83%a9%e3%83%aa>#</a></h2><p>Kubernetes向けTypeScriptのライブラリ</p><ul><li><a href=https://github.com/cdk8s-team/cdk8s>cdk8s</a></li><li><a href=https://github.com/tommy351/kosko>kosko</a></li></ul><p>KubernetesのDefinitionが定義れているComponentは<a href=https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>があります。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#移行後の各componentのファイル数の規模感>移行後の各Componentのファイル数の規模感</a></li><li><a href=#問題意識>問題意識</a><ul><li><a href=#typescriptでmanifestの保守面の問題を解決する>TypeScriptでManifestの保守面の問題を解決する</a></li></ul></li><li><a href=#typescriptでkubernetesを書くための支援ライブラリとschema>TypeScriptでKubernetesを書くための支援ライブラリとSchema</a></li><li><a href=#他のライブラリ>他のライブラリ</a></li></ul></nav></div></aside></main></body></html>