<!doctype html><html lang=ja-jp dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="BFFとIstio #  Istio の利用 #  Istio は既存のマイクロサービスに対して後付で導入することができ、 通信を可観測にしたり、負荷分散を実施したり、Proxy としての機能を持っています。 Kubernetes 上で稼働するマイクロサービスの通信をよりプログラマブルに扱える機能を提供しています。
実際に触ってみると istioが謳っているこれらの機能は有用で、サービスメッシュはKubernetesを運用する上で必要不可欠であることを実感させられます。
さて、詳細な部分はドキュメントを読むのが望ましいですが、とっつきにくい部分もあるのでフロントエンドのエンジニアが使うと便利な機能を紹介しつつ Istio のコンポーネント紹介します。
IstioとEnvoyの関係 #  まずはIstioとEnvoyの関係について知っておく必要があります。
Envoyはそれ自体がProxyであり、nginxやApacheなどのL7 LBと似たような機能を提供しています。 大きな違いとして、Envoy はテレメトリが標準で豊富だったり、APIによる構成変更が可能だったりプログラマブルにコントロールできる機能を豊富に持っています。 すなわち再起動をせずに構成変更が容易であり、Argo RolloutsのCanary Deployで紹介したように Traffic Weight を柔軟に変更することが可能になります。
IstioはこのEnvoyを利用して、Kubernetes上で稼働するマイクロサービス間の通信を観測するために Control Plane から各 Pod に Sidecar として注入します。 Istioから提供されているEnvoyのDocker Imageはistio-proxyという名前で提供されており、kubectl get pod [podname]などで構成を確認するとistio-proxyという名前を確認することができます。
Envoy 単体では通常以下のような YAML を記述して起動時に読み込ませることで Envoy の設定変更を実施します。
 https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/examples  Istio の場合、Envoy はすでに起動された状態で存在しているため、既存の設定が存在しています。 そのため、この構成変更をしたい場合はEnvoyFilterを利用します。
 https://istio.io/latest/docs/reference/config/networking/envoy-filter/  ただ普段書くような Traffic Management 用の設定は別のコンポーネントを利用して簡易に記述することができます。
   Component 名 役割     Gateway 受け入れ可能なホスト名、ポート番号、プロトコルなどを記述する   Virtual Service PATH単位のルーティングの設定が可能。Traffic Weight の指定、Header や Query Parameter による個別のルーティング先もここで指定する。   Service Entry Kubernetes クラスタから外部へのアクセス制限など。    その他（https://istio."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="BFFとIstio"><meta property="og:description" content="BFFとIstio #  Istio の利用 #  Istio は既存のマイクロサービスに対して後付で導入することができ、 通信を可観測にしたり、負荷分散を実施したり、Proxy としての機能を持っています。 Kubernetes 上で稼働するマイクロサービスの通信をよりプログラマブルに扱える機能を提供しています。
実際に触ってみると istioが謳っているこれらの機能は有用で、サービスメッシュはKubernetesを運用する上で必要不可欠であることを実感させられます。
さて、詳細な部分はドキュメントを読むのが望ましいですが、とっつきにくい部分もあるのでフロントエンドのエンジニアが使うと便利な機能を紹介しつつ Istio のコンポーネント紹介します。
IstioとEnvoyの関係 #  まずはIstioとEnvoyの関係について知っておく必要があります。
Envoyはそれ自体がProxyであり、nginxやApacheなどのL7 LBと似たような機能を提供しています。 大きな違いとして、Envoy はテレメトリが標準で豊富だったり、APIによる構成変更が可能だったりプログラマブルにコントロールできる機能を豊富に持っています。 すなわち再起動をせずに構成変更が容易であり、Argo RolloutsのCanary Deployで紹介したように Traffic Weight を柔軟に変更することが可能になります。
IstioはこのEnvoyを利用して、Kubernetes上で稼働するマイクロサービス間の通信を観測するために Control Plane から各 Pod に Sidecar として注入します。 Istioから提供されているEnvoyのDocker Imageはistio-proxyという名前で提供されており、kubectl get pod [podname]などで構成を確認するとistio-proxyという名前を確認することができます。
Envoy 単体では通常以下のような YAML を記述して起動時に読み込ませることで Envoy の設定変更を実施します。
 https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/examples  Istio の場合、Envoy はすでに起動された状態で存在しているため、既存の設定が存在しています。 そのため、この構成変更をしたい場合はEnvoyFilterを利用します。
 https://istio.io/latest/docs/reference/config/networking/envoy-filter/  ただ普段書くような Traffic Management 用の設定は別のコンポーネントを利用して簡易に記述することができます。
   Component 名 役割     Gateway 受け入れ可能なホスト名、ポート番号、プロトコルなどを記述する   Virtual Service PATH単位のルーティングの設定が可能。Traffic Weight の指定、Header や Query Parameter による個別のルーティング先もここで指定する。   Service Entry Kubernetes クラスタから外部へのアクセス制限など。    その他（https://istio."><meta property="og:type" content="article"><meta property="og:url" content="https://dwango.github.io/nicolive-kubernetes-migration-handbook-2022/docs/service-mesh/istio/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-06-02T17:14:12+09:00"><title>BFFとIstio | ニコニコ生放送 Webフロントエンド Kubernetes移行ハンドブック 2022</title><link rel=manifest href=/nicolive-kubernetes-migration-handbook-2022/manifest.json><link rel=icon href=/nicolive-kubernetes-migration-handbook-2022/favicon.png type=image/x-icon><link rel=stylesheet href=/nicolive-kubernetes-migration-handbook-2022/book.min.fcc3ce6727c2b2b91bc9a518374b77e2097222f7fe4dc0016db675da315da284.css integrity="sha256-/MPOZyfCsrkbyaUYN0t34glyIvf+TcABbbZ12jFdooQ=" crossorigin=anonymous><script defer src=/nicolive-kubernetes-migration-handbook-2022/flexsearch.min.js></script>
<script defer src=/nicolive-kubernetes-migration-handbook-2022/en.search.min.316dfec6e198e1d4e40887d7250e8b92d7bde449cce89841b69417adbdc06208.js integrity="sha256-MW3+xuGY4dTkCIfXJQ6Lkte95EnM6JhBtpQXrb3AYgg=" crossorigin=anonymous></script>
<script defer src=/nicolive-kubernetes-migration-handbook-2022/sw.min.dd2d6bf3c93d9223651db8ea5867f95fed658724b711f7b9e9e1d8aa46a84ebd.js integrity="sha256-3S1r88k9kiNlHbjqWGf5X+1lhyS3Efe56eHYqkaoTr0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/nicolive-kubernetes-migration-handbook-2022/><span>ニコニコ生放送 Webフロントエンド Kubernetes移行ハンドブック 2022</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>ネットワーク</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/network/architecture/>移行前・移行中・移行後のネットワーク設計</a></li></ul></li><li><span>Manifest管理</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/manifest/manifest-management/>KubernetesのManifest管理</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-written-by-typescript/>TypeScriptでKubernetesのmanifestを記述する</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-generator-architecture/>TypeScriptでManifestを生成するGeneratorのアーキテクチャ</a></li></ul></li><li><span>Continuous Delivery</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/ci/argo-cd/>Argo CDの利用</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/ci/argo-rollouts/>Argo Rolloutsの利用</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/ci/slack-bot/>Slack Botによる自動化</a></li></ul></li><li><span>Service Mesh (Istio)</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/service-mesh/istio/ class=active>BFFとIstio</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/service-mesh/access-log/>アクセスログ</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/service-mesh/traffic-management/>Istio Ingress Gatewayの設定</a></li></ul></li><li><span>Rate Limit</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/rate-limit/global-ratelimit/>Global RateLimit</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/rate-limit/local-ratelimit/>Local RateLimit</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/rate-limit/ratelimit-is-unless/>RateLimitで負荷の上昇を防げないパターン</a></li></ul></li><li><span>スケーリング</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/scalability/horizontal-pod-autoscaler/>水平スケール</a></li></ul></li><li><span>負荷</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/performance/load-test/>負荷試験</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/performance/monitoring/>モニタリング</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/performance/load-balancing/>負荷分散</a></li></ul></li><li><span>Docker SwarmからKubernetesへの移行</span><ul><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/migrate-practice/migrate-docker-swarm-to-kubernetes/>移行の実施</a></li><li><a href=/nicolive-kubernetes-migration-handbook-2022/docs/migrate-practice/application/>アプリケーションの移行</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/nicolive-kubernetes-migration-handbook-2022/svg/menu.svg class=book-icon alt=Menu></label>
<strong>BFFとIstio</strong>
<label for=toc-control><img src=/nicolive-kubernetes-migration-handbook-2022/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#istio-の利用>Istio の利用</a></li><li><a href=#istioとenvoyの関係>IstioとEnvoyの関係</a></li><li><a href=#ingress-gatewayをセットアップする>Ingress Gatewayをセットアップする</a><ul><li><a href=#istio-system以外のnamespaceでistiooperatorが利用できるようにする>istio-system以外のnamespaceでIstioOperatorが利用できるようにする</a></li></ul></li><li><a href=#istio-proxyのサイドカーが不要なケース>istio-proxyのサイドカーが不要なケース</a><ul><li><a href=#job>Job</a></li></ul></li><li><a href=#bffでサービスメッシュが有効だと何が良いか>BFFでサービスメッシュが有効だと何が良いか</a></li></ul></nav></aside></header><article class=markdown><h1 id=bffとistio>BFFとIstio
<a class=anchor href=#bff%e3%81%a8istio>#</a></h1><h2 id=istio-の利用>Istio の利用
<a class=anchor href=#istio-%e3%81%ae%e5%88%a9%e7%94%a8>#</a></h2><p>Istio は既存のマイクロサービスに対して後付で導入することができ、
通信を可観測にしたり、負荷分散を実施したり、Proxy としての機能を持っています。
Kubernetes 上で稼働するマイクロサービスの通信をよりプログラマブルに扱える機能を提供しています。</p><p>実際に触ってみると istioが謳っているこれらの機能は有用で、サービスメッシュはKubernetesを運用する上で必要不可欠であることを実感させられます。</p><p>さて、詳細な部分はドキュメントを読むのが望ましいですが、とっつきにくい部分もあるのでフロントエンドのエンジニアが使うと便利な機能を紹介しつつ
Istio のコンポーネント紹介します。</p><h2 id=istioとenvoyの関係>IstioとEnvoyの関係
<a class=anchor href=#istio%e3%81%a8envoy%e3%81%ae%e9%96%a2%e4%bf%82>#</a></h2><p>まずはIstioとEnvoyの関係について知っておく必要があります。</p><p>Envoyはそれ自体がProxyであり、nginxやApacheなどのL7 LBと似たような機能を提供しています。
大きな違いとして、Envoy はテレメトリが標準で豊富だったり、APIによる構成変更が可能だったりプログラマブルにコントロールできる機能を豊富に持っています。
すなわち再起動をせずに構成変更が容易であり、<a href=/docs/04/argo-rollouts/#canary-deploy%e3%82%92%e5%ae%9f%e6%96%bd%e3%81%99%e3%82%8b>Argo RolloutsのCanary Deploy</a>で紹介したように Traffic Weight を柔軟に変更することが可能になります。</p><p>IstioはこのEnvoyを利用して、Kubernetes上で稼働するマイクロサービス間の通信を観測するために Control Plane から各 Pod に Sidecar として注入します。
Istioから提供されているEnvoyのDocker Imageは<code>istio-proxy</code>という名前で提供されており、<code>kubectl get pod [podname]</code>などで構成を確認すると<code>istio-proxy</code>という名前を確認することができます。</p><p>Envoy 単体では通常以下のような YAML を記述して起動時に読み込ませることで Envoy の設定変更を実施します。</p><ul><li><a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/examples>https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/examples</a></li></ul><p>Istio の場合、Envoy はすでに起動された状態で存在しているため、既存の設定が存在しています。
そのため、この構成変更をしたい場合は<code>EnvoyFilter</code>を利用します。</p><ul><li><a href=https://istio.io/latest/docs/reference/config/networking/envoy-filter/>https://istio.io/latest/docs/reference/config/networking/envoy-filter/</a></li></ul><p>ただ普段書くような Traffic Management 用の設定は別のコンポーネントを利用して簡易に記述することができます。</p><table><thead><tr><th style=text-align:left>Component 名</th><th style=text-align:left>役割</th></tr></thead><tbody><tr><td style=text-align:left>Gateway</td><td style=text-align:left>受け入れ可能なホスト名、ポート番号、プロトコルなどを記述する</td></tr><tr><td style=text-align:left>Virtual Service</td><td style=text-align:left><code>PATH</code>単位のルーティングの設定が可能。Traffic Weight の指定、Header や Query Parameter による個別のルーティング先もここで指定する。</td></tr><tr><td style=text-align:left>Service Entry</td><td style=text-align:left>Kubernetes クラスタから外部へのアクセス制限など。</td></tr></tbody></table><p>その他（<a href=https://istio.io/latest/docs/reference/config/networking>https://istio.io/latest/docs/reference/config/networking</a>）にもComponentはありますが最初に指定するものはおおよそ上記の3つでしょう。</p><h2 id=ingress-gatewayをセットアップする>Ingress Gatewayをセットアップする
<a class=anchor href=#ingress-gateway%e3%82%92%e3%82%bb%e3%83%83%e3%83%88%e3%82%a2%e3%83%83%e3%83%97%e3%81%99%e3%82%8b>#</a></h2><p>IstioはSidecarにistio-proxyを注入するだけではなく、Ingress Gatewayを作成することでその機能をより活かすことができます。</p><p>IngressGatewayは<code>namespace</code>やKubernetesの境界に位置するGatewayとして機能させることで管理下にあるマイクロサービスに対するアクセスの制御ができます。
Webフロントエンドが管理するような、Internetからアクセスされ、他マイクロサービスから直接CALLが必要ないマイクロサービスはIngress Gatewayを通して管理すると負荷対策やデプロイの運用が楽になります。</p><p><img src=../istio-ingress-gateway.svg alt="istio ingress gatewayの概略図"></p><p>IstioにおけるIngress Gatewayのセットアップは<code>IstioOperator</code>利用して実施します。</p><ul><li><a href=https://istio.io/latest/docs/setup/install/operator/>https://istio.io/latest/docs/setup/install/operator/</a></li></ul><h3 id=istio-system以外のnamespaceでistiooperatorが利用できるようにする>istio-system以外のnamespaceでIstioOperatorが利用できるようにする
<a class=anchor href=#istio-system%e4%bb%a5%e5%a4%96%e3%81%aenamespace%e3%81%a7istiooperator%e3%81%8c%e5%88%a9%e7%94%a8%e3%81%a7%e3%81%8d%e3%82%8b%e3%82%88%e3%81%86%e3%81%ab%e3%81%99%e3%82%8b>#</a></h3><p>IstioOperatorの管理をnamespaceを分けて管理したい場合、デフォルトの設定のままではインストールすることができません。例えば以下のようにIstioOperator(<code>Deployment</code>)をセットアップすると<code>watchedNamespaces</code>で指定された<code>istio-system</code>でのみ<code>IstioOperator</code>のコンポーネントが利用できません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ helm install istio-operator manifests/charts/istio-operator <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --set watchedNamespaces<span style=color:#f92672>=</span>istio-system <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -n istio-operator <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --set revision<span style=color:#f92672>=</span>1-9-0
</span></span></code></pre></div><p>すでにインストールされた環境下の場合、次のようなコマンドでIstioOperatorが利用可能なnamespaceを確認することができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get deployment -n istio-operator -l operator.istio.io/component<span style=color:#f92672>=</span>IstioOperator -o yaml | grep -A1 <span style=color:#e6db74>&#34;name: WATCH_NAMESPACE&#34;</span>
</span></span></code></pre></div><p>環境変数<code>WATCH_NAMESPACE</code>を更新することで<code>IstioOperator</code>のコンポーネントが利用することができるようになります。
例えば<code>myteam</code>という<code>namespace</code>を追加したい場合は次のように実施します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl set env deployment/istio-operator-1-11-4 WATCH_NAMESPACE<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;istio-system,myteam&#34;</span> -n istio-operator
</span></span></code></pre></div><p>Ingress Gatewayの具体的な設定は<a href=/docs/05/traffic-management/>次の節</a>で紹介しています。</p><h2 id=istio-proxyのサイドカーが不要なケース>istio-proxyのサイドカーが不要なケース
<a class=anchor href=#istio-proxy%e3%81%ae%e3%82%b5%e3%82%a4%e3%83%89%e3%82%ab%e3%83%bc%e3%81%8c%e4%b8%8d%e8%a6%81%e3%81%aa%e3%82%b1%e3%83%bc%e3%82%b9>#</a></h2><h3 id=job>Job
<a class=anchor href=#job>#</a></h3><p>Istioを有効にした場合Podに対してistio-proxyがsidecarとして挿入されます。
しかしながら、不要なケースも存在します。
1回だけ実行されるJobとして実行されるPodはJobが終了したするとPodのStatusがCompletedになりますが、istio-proxyは常駐するサーバーであるためJobがCompletedになりません。</p><p>そのため、JobはPod Templateに対して<code>sidecar.istio.io/inject: "false"</code>を指定することでSidecarを注入させないようにしています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Job</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myjob</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>sidecar.istio.io/inject</span>: <span style=color:#e6db74>&#34;false&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 省略</span>
</span></span></code></pre></div><h2 id=bffでサービスメッシュが有効だと何が良いか>BFFでサービスメッシュが有効だと何が良いか
<a class=anchor href=#bff%e3%81%a7%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e3%83%a1%e3%83%83%e3%82%b7%e3%83%a5%e3%81%8c%e6%9c%89%e5%8a%b9%e3%81%a0%e3%81%a8%e4%bd%95%e3%81%8c%e8%89%af%e3%81%84%e3%81%8b>#</a></h2><p>最も嬉しいのは可観測性にあります。
BFFはその特性上、各マイクロサービスから情報をかき集め、場合によってはServer Side Rendering(SSR)を実施します。
最終的な結果はユーザーに届くため、一連の処理がユーザー体験に直接影響します。
ゆえに、明らかにレスポンスタイムが悪いマイクロサービスがある場合いくつかの行動を取ることができます。
特定のバージョンから悪化しているのであればロールバックを実行したり、
Client Side Rendering可能な情報であれば最初のHTMLを構成するためのクリティカルパスから除外したりすることが可能です。
少なくとも、継続的な監視は問題を明確にし、物事の優先度を合理的に決定することができます。
<a href=/docs/08/loadtest/>負荷試験</a>や<a href=/docs/08/monitoring/>モニタリング</a>の節で具体的なMetricsの可視化を紹介しています。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#istio-の利用>Istio の利用</a></li><li><a href=#istioとenvoyの関係>IstioとEnvoyの関係</a></li><li><a href=#ingress-gatewayをセットアップする>Ingress Gatewayをセットアップする</a><ul><li><a href=#istio-system以外のnamespaceでistiooperatorが利用できるようにする>istio-system以外のnamespaceでIstioOperatorが利用できるようにする</a></li></ul></li><li><a href=#istio-proxyのサイドカーが不要なケース>istio-proxyのサイドカーが不要なケース</a><ul><li><a href=#job>Job</a></li></ul></li><li><a href=#bffでサービスメッシュが有効だと何が良いか>BFFでサービスメッシュが有効だと何が良いか</a></li></ul></nav></div></aside></main></body></html>